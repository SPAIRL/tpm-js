<h2>Key Certificates And Trust</h2>

<p>
  Cryptographic keys are just numbers - by themselves they don't convey any meaning
  of trust. Trust in cryptographic keys is gained through <a href="https://en.wikipedia.org/wiki/Public_key_certificate">public key certificates</a>.

  <br> As we've seen, keys generated by the TPM are protected by their parent keys
  - if you trust the parent key is not compromised, then you can trust all the
  keys rooted under it. What about the <b>primary key</b>? How do you know it's
  coming from a genuine TPM device, that's conformant to the spec? The answer is
  the primary key certificate, issued by the TPM manufacturer.
</p>

<h3>EK Certificate</h3>

<p>
  The EK certificate certifies the primary endorsement key. It is issued by the TPM
  vendor during manufacturing, and signed by a key that's only available to the
  vendor. The vendor's root key certificate is usually distributed on the vendor's
  website, where it can be downloaded over SSL.
</p>

<p>
  EK certificate provisioning process looks like this:

  <img src="images/ek_cert_1.svg" class="img-responsive center-block" style="max-width:70%"
    alt="EK Cert">

  <br> At the end, a signed EK certificate is stored in the TPM's NVDATA.
</p>

<p>
  The TPM user can, at any time, read the EK certificate from NVDATA, and verify
  its signature chain:

  <img src="images/ek_cert_2.svg" class="img-responsive center-block" style="max-width:70%"
    alt="EK Cert">

  <br>
  <div class="alert alert-info" role="alert">If the certificate is valid, and you trust the vendor - then the primary endorsement
    key can be trusted.
    <br>If the EK is trusted, then all the keys protected by it can be trusted.</div>
</p>

<h3>EK Template</h3>

<p>
  EK is derived from the eseed and a TPM2B_PUBLIC template. TCG defines two <b>default
  templates</b> for EKs, one for RSA keys and one for ECC keys. If a vendor certifies
  a key other than the default RSA-EK or ECC-EK, they have to store the template
  used for creation and its <i>unique</i> value in NVDATA, next to the EK certificate.

  <br> There are reserved NV indices for RSA-EK certificate and ECC-EK certificate.
  There are reserved NV indices for the EK templates.

</p>

<h3>EK Certificate Example</h3>
<p>
  Let's see this in action. First, we'll create the root keys and self-signed certificate on the vendor side:

  <br> {{ macros.code_cell(input="

  // Creates a self-signed root certificate.
  function CreateRootCert(keys) {
    var cert = forge.pki.createCertificate();
    cert.publicKey = keys.publicKey;
    cert.serialNumber = '01';
    cert.validity.notBefore = new Date();
    cert.validity.notAfter = new Date();
    cert.validity.notAfter.setFullYear(cert.validity.notBefore.getFullYear() + 1);
    var attrs = [{
      name: 'commonName',
      value: 'vendor.com'
    }];
    cert.setSubject(attrs);
    cert.setIssuer(attrs);
    cert.setExtensions([{
      name: 'basicConstraints',
      cA: true
    }, {
      name: 'keyUsage',
      keyCertSign: true,
      digitalSignature: true,
      nonRepudiation: true,
      keyEncipherment: true,
      dataEncipherment: true
    }, {
      name: 'subjectAltName',
      altNames: [{
        type: 6, // URI
        value: 'http://vendor.com/webid'
      }, {
        type: 7, // IP
        ip: '127.0.0.1'
      }]
    }, {
      name: 'subjectKeyIdentifier'
    }]);

    // self-sign certificate
    cert.sign(keys.privateKey);

    return cert;
  };

  vendor_root_keys = forge.pki.rsa.generateKeyPair(2048);
  vendor_root_cert = CreateRootCert(vendor_root_keys);

  print('Vendor root cert:', forge.pki.certificateToPem(vendor_root_cert));
  print('OK');
  ")}}
</p>

<p>
  At manufacturing time, the TPM's EK certificate is provisioned and stored on the device:

  <br> {{ macros.code_cell(input="
  // Create primary key endorsement key from the default template.
  var ek = app.CreatePrimaryEndorsementKey();
  assert(ek.rc == TPM2_RC_SUCCESS, 'CreatePrimary failed');
  assert(app.FlushContext(ek.handle) == TPM2_RC_SUCCESS, 'FlushContext failed');

  // Build public key object from key material.
  var bn_n = new forge.jsbn.BigInteger(ek.rsa_public_n.substr(2), 16);
  var bn_e = new forge.jsbn.BigInteger('10001', 16);
  var ek_pub = new forge.pki.setRsaPublicKey(bn_n, bn_e);

  // Build EK certificate.
  var ek_cert = forge.pki.createCertificate();
  ek_cert.publicKey = ek_pub;
  ek_cert.setSubject([{
    name: 'commonName',
    value: 'example.org'
  }]);

  // Sign EK cert with the vendor's root key.
  ek_cert.setIssuer(vendor_root_cert.subject.attributes);
  ek_cert.sign(vendor_root_keys.privateKey);

  // Verify certificate.
  assert(vendor_root_cert.verify(ek_cert) == true, 'Cert verification failed');
  print('EK cert:', forge.pki.certificateToPem(ek_cert));

  // Convert to DER format.
  var der = forge.asn1.toDer(forge.pki.certificateToAsn1(ek_cert));

  // Create NV index for the certificate.
  assert(app.NvDefineSpace(EK_CERT_NV_INDEX, der.length()) == TPM2_RC_SUCCESS, 'NvDefineSpace failed');

  // Store certificate in NV data.
  assert(app.NvWrite(EK_CERT_NV_INDEX, StringToStdVector(der.data)) == TPM2_RC_SUCCESS, 'NvWrite failed');

  print('OK');
  ")}}

  <br> Writing data to NV storage is done with <code>TPM2_CC_NV_DefineSpace</code> and <code>TPM2_CC_NV_Write</code>.
</p>

<p>
  At runtime, the EK certificate is read from the device, and verified against the vendor's root certificate:

  <br> {{ macros.code_cell(input="
  // Create primary key endorsement key from the default template.
  var ek = app.CreatePrimaryEndorsementKey();
  assert(ek.rc == TPM2_RC_SUCCESS, 'CreatePrimary failed');
  assert(app.FlushContext(ek.handle) == TPM2_RC_SUCCESS, 'FlushContext failed');

  // Build public key object from key material.
  var bn_n = new forge.jsbn.BigInteger(ek.rsa_public_n.substr(2), 16);
  var bn_e = new forge.jsbn.BigInteger('10001', 16);
  var ek_pub = new forge.pki.setRsaPublicKey(bn_n, bn_e);

  // Read cert size.
  var public_result = app.NvReadPublic(EK_CERT_NV_INDEX);
  assert(public_result.rc == TPM2_RC_SUCCESS, 'NvReadPublic failed');

  // Read cert buffer.
  var read_result = app.NvRead(EK_CERT_NV_INDEX, public_result.data_size, /*offset*/0);
  assert(read_result.rc == TPM2_RC_SUCCESS, 'NvRead failed');
  var der = ByteArrayToForgeBuffer(read_result.data);
  var ek_cert = forge.pki.certificateFromAsn1(forge.asn1.fromDer(der));
  print('EK cert:', forge.pki.certificateToPem(ek_cert));

  // Verify certificate's public key matches EK.
  assert(_.isEqual(ek_pub.n, ek_cert.publicKey.n), 'Public key does not match');
  assert(_.isEqual(ek_pub.e, ek_cert.publicKey.e), 'Public key does not match');

  // Verify certificate.
  assert(vendor_root_cert.verify(ek_cert) == true, 'Cert verification failed');

  print('OK');
  ")}}

  <br> Reading data from NV storage is done with <code>TPM2_CC_NV_ReadPublic</code> and <code>TPM2_CC_NV_Read</code>.
</p>
